---
layout:     post
title:      "leet_code刷题"
subtitle:   "自己写完后观摩大佬的代码"
date:       2018-11-04 20:00:00
author:     "彭西明"
header-img: "img/mc/g3.jpg"
tags:
    - C
---

# 算法练习

    使用的是大佬敲的我认为比较好的，但也不是盲目崇拜，而直接否定自己，正所谓去粗取精嘛！

## Day1

### 1 两数之和

### 2 两数相加

### 3 无重复字符的最长子串

### 4 两数组的中位数

大神写的代码

``` c
double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {
    double sum[nums1Size+nums2Size];

 //m1[nums1Size],m2[nums2Size];
 // m1=nums1;
  //m2=nums2;
    int i,j,x=0,y=0,z;
    double result;
    z=nums1Size+nums2Size;
    for(i=0;i<z;i++)
    {
        if((x!=nums1Size)&&(y!=nums2Size))
             { 
                 if(nums1[x]<=nums2[y])
                {
                    sum[i]=nums1[x];
                   x++;


               }
                else if(nums1[x]>nums2[y])
                {
                    sum[i]=nums2[y];
                    y++;


                }
            } 
          else if(x==nums1Size)sum[i]=nums2[y++];
           else if(y==nums2Size)sum[i]=nums1[x++];
    }
    if(z%2==1)result=(double)sum[z/2];
    else if(z%2==0)result=(double)(sum[z/2]+sum[z/2-1])/2;    
    return result;
}
   
```

我写的代码

``` C
double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {
    int *m,*n,lm,ln;
    if(nums1Size >nums2Size){
        m = nums2;
        n = nums1;
        lm = nums2Size;
        ln = nums1Size;
    }else{
        m = nums1;
        n = nums2;
        lm = nums1Size;
        ln = nums2Size; 
    }
    
    int imin = 0;
    int imax = lm;
    int half = (lm + ln +1)/2;
    int i,j;
    int max_left;
    int min_right;
    while(imin<=imax){
        i = (imin + imax)/2;
        j = half -i;
        if( i <lm && n[j-1] >m[i]){
            imin++;
        }else if(i>0 && m[i-1]>n[j]){
            imin--;
        }else{
            if(i==0) max_left = n[j-1];
            else if(j==0){ max_left = m[i-1];}
            else { max_left = (m[i-1]>n[j-1])?m[i-1]:n[j-1];}
            
            if((lm+ln)%2==1) return max_left;
            
            if(i==lm) min_right = m[i];
            else if(j==ln) min_right = n[j];
            else{ min_right = (m[i]<n[j])?m[i]:n[j];}
            
            return (max_left+min_right)/2.0;
            
        }
        
    }
    
   return 0.0 
}
```
